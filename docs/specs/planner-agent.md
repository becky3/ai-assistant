# 実装計画サブエージェント

## 概要

GitHub Issueやユーザーからの提案を元に、仕様駆動開発の観点で詳細な実装計画を立案するClaude Codeサブエージェント。仕様書テンプレートに準拠した技術仕様、受け入れ条件、テスト方針を含む計画書を生成する。

## 背景

Learning Companionプロジェクトは仕様駆動開発を採用しており、実装前に `docs/specs/` に仕様書を作成する必要がある。しかし、仕様書の作成には以下の課題がある:

- **テンプレート遵守**: 必須セクション（概要、背景、ユーザーストーリー、技術仕様、受け入れ条件など）を漏れなく含める必要がある
- **受け入れ条件の品質**: 具体的で検証可能なACを定義するには経験が必要
- **既存コードとの整合性**: プロジェクトの既存実装パターン、コーディング規約、LLM使い分けルールを踏まえる必要がある
- **時間コスト**: ゼロから仕様書を書くには時間がかかる

これらを解消するため、Issue や提案内容を分析し、プロジェクトの規約に準拠した実装計画を自動生成するサブエージェントを実装する。

## ユーザーストーリー

- 開発者として、新機能のIssueを作成した後に `plannerサブエージェント` で実装計画を生成し、仕様書のドラフトを作成したい
- 開発者として、提案内容から技術仕様・受け入れ条件・テスト方針を含む詳細計画を得て、実装の見通しを立てたい
- 開発者として、既存の仕様書テンプレートと整合性のある計画書を自動生成し、レビューの手戻りを減らしたい
- 開発者として、計画書をベースに実装を進め、仕様駆動開発のフローを効率化したい

## 技術仕様

### サブエージェント定義

**ファイル**: `.claude/agents/planner.md`

**メタデータ:**
```yaml
name: planner
description: Issue・提案内容から実装計画を立案する専門家。仕様書テンプレートに基づき、技術仕様・受け入れ条件・テスト方針を含む詳細な実装計画を作成する。
tools: Read, Grep, Glob, Bash
model: sonnet
permissionMode: default
```

### 計画プロセス

計画は以下の8ステップで進める:

#### 1. 要件の理解と分析

Issue や提案内容から以下を抽出:
- 目的（何を実現したいのか）
- 背景（なぜ必要なのか）
- 制約条件（技術的制約、既存コードとの整合性）
- ステークホルダー（誰が使うのか）
- 権限モデル（操作を実行できるユーザーの範囲。制限不要の場合もその理由を明記）

**Issue内容と実態の検証**: Issue に「実装済み」「既に存在する」等の記述がある場合、必ず実際のコードを確認し、差異がある場合は計画書の「前提の確認・補足」セクションで明示する。

#### 2. 既存コードベースの調査

- `docs/specs/` の既存仕様書を確認し、類似機能や関連機能を特定
- `src/` ディレクトリの既存実装パターンを把握（応答形式、スレッド処理、エラー表示パターン等）
- `CLAUDE.md` のコーディング規約とプロジェクト構造を確認
- 関連するテストファイル (`tests/`) の存在と命名規則を確認
- 既存の振る舞いパターン（例: Slackのスレッド応答、メッセージフォーマット）を把握し、新機能でも同じパターンを踏襲するよう計画に反映する

#### 3. 技術仕様の設計

以下を明確化:
- **入出力仕様**: 具体的な入力データと期待される出力（サンプル付き）。コマンド型の入力がある場合は、各トークンの判別ルール（例: 「`http://` または `https://` で始まる文字列はURLとして扱う」）を明記する
- **処理フロー**: 処理の流れと各ステップの責務
- **データモデル**: 必要なDB変更、新規テーブル、カラム追加。既存モデル間のリレーションシップ（外部キー、カスケード削除）への影響を必ず確認し、削除・変更時のデータ整合性方針を明記する
- **API設計**: 外部APIやLLM APIの使用方法
- **エラーハンドリング**: 異常系シナリオと対応方針

#### 4. LLMプロバイダーの選定

プロジェクトの「LLM使い分けルール」（`docs/specs/overview.md`）に基づき、タスクの性質を評価:
- **ローカルLLM (LM Studio)**: 単純・定型的なタスク（要約、抽出）
- **オンラインLLM (OpenAI/Claude)**: 推論力が必要なタスク（応答、提案）
- 選定理由を明記

#### 5. 受け入れ条件 (AC) の定義

以下の基準で AC を作成:
- `- [ ]` 形式のチェックボックスとして記載
- 各 AC が具体的で検証可能（テスト可能）
- 「何を」検証するかが明確（「どうやって」は実装の詳細）
- 正常系・異常系・境界値を網羅
- テスト名規約に従える粒度（`test_ac{N}_...` で命名可能）

**AC番号の競合回避**: 既存仕様書の AC を具体化・拡張する場合、親仕様書の AC 番号と競合しないようにする:
- 独立した新機能仕様: `AC1`, `AC2`, ... （新しい仕様書ファイルで管理）
- 既存 AC のサブ機能: `AC{親番号}.1`, `AC{親番号}.2`, ... （例: 親の AC7 を詳細化 → `AC7.1`, `AC7.2`, ...）

#### 6. 関連ファイルの特定

実装に関わるファイルをリストアップ:
- 新規作成が必要なモジュール・クラス
- 変更対象となる既存ファイル
- 対応するテストファイル名
- 更新が必要なドキュメント

各ファイルの役割を簡潔に記載する。

#### 7. テスト方針の策定

以下を含む:
- 単体テスト、統合テスト、E2Eテストの方針
- テスト名規約（AC番号との対応）
- カバレッジ目標（必要に応じて）

#### 8. 実装の優先順位とリスク評価

- 依存関係に基づいた実装順序
- 技術的リスク（不確実性の高い部分、調査が必要な箇所）
- 既存機能への影響範囲
- フォールバック戦略

### 入出力仕様

#### 入力

ユーザーがClaude Codeで以下のように呼び出す:

**パターン1: Issue番号を指定**
```
plannerサブエージェントを使用してIssue #42 の実装計画を立ててください
```

**パターン2: 提案内容を直接入力**
```
plannerサブエージェントで「Slackメッセージの反応機能」の実装計画を作成してください
```

**パターン3: 既存の提案文書を参照**
```
plannerサブエージェントで docs/proposals/reaction-feature.md の実装計画を立ててください
```

#### 出力

以下の構造で計画書を生成する（`docs/specs/overview.md` のテンプレートに準拠）:

```markdown
# F{N}: 機能名

## 概要
[1-2文で機能の要約]

## 背景
[なぜこの機能が必要なのか、どのような課題を解決するのか]

## ユーザーストーリー
- [ペルソナ]として、[目的]のために、[機能]を使いたい

## 技術仕様

### 入出力仕様
[具体例を含む入出力仕様]

### 処理フロー
[ステップごとの処理の流れ]

### データモデル（必要な場合）
[DB変更、新規テーブル定義など]

### API設計（必要な場合）
[外部APIやLLM APIの使用方法]

## 使用LLMプロバイダー
[ローカル/オンライン/両方] — [選定理由]

## 前提の確認・補足（差異がある場合のみ）
- [Issue記載内容と実態の差異があれば記載]

## 受け入れ条件
（既存ACのサブ機能の場合は `AC{親番号}.{連番}` を使用）

- [ ] AC1: [検証可能な条件1]
- [ ] AC2: [検証可能な条件2]
  ...

## 関連ファイル
| ファイル | 役割 |
|---------|------|
| `src/path/to/module.py` | [役割の説明] |
  ...

## テスト方針
- **単体テスト**: [説明]
- **統合テスト**: [説明]
  ...

## 実装の優先順位
1. [最優先タスク]
2. [次のタスク]
  ...

## 技術的リスク
- [リスク1]: [対策]
  ...
```

計画書は `docs/specs/` に保存するか、ユーザーに提示して承認を得る。

## 使用LLMプロバイダー

**Claude Code (Sonnet モデル)** — サブエージェントとして使用

**選定理由:**
- 実装計画の立案は、要件分析、既存コード理解、技術設計、リスク評価など、高度な推論力が必要なタスク
- サブエージェント定義のメタデータで `model: sonnet` を指定し、Sonnetモデルで実行
- 仕様駆動開発の観点からの計画には、文脈理解と論理的な設計能力が重要

## 受け入れ条件

- [ ] AC1: `.claude/agents/planner.md` が正しく作成され、Claude Codeから呼び出せる
- [ ] AC2: Issue番号を指定した場合、該当Issueの内容を読み込んで計画を立案できる
- [ ] AC3: 提案内容を直接入力した場合、その内容をもとに計画を立案できる
- [ ] AC4: 既存の仕様書テンプレート（`docs/specs/overview.md`）に準拠した構造で計画書を生成できる
- [ ] AC5: 計画書に必須セクション（概要、背景、ユーザーストーリー、技術仕様、受け入れ条件、関連ファイル、テスト方針）が含まれる
- [ ] AC6: 受け入れ条件が `- [ ]` 形式のチェックボックスとして記載される
- [ ] AC7: 各受け入れ条件が具体的で検証可能（テスト可能）である
- [ ] AC8: 既存コードベースの調査結果を計画に反映できる（類似機能の参照、実装パターンの踏襲）
- [ ] AC9: プロジェクトのLLM使い分けルール（`docs/specs/overview.md`）に基づいてLLMプロバイダーを選定し、理由を説明できる
- [ ] AC10: 関連ファイルのリストに各ファイルの役割が記載される
- [ ] AC11: テスト名規約（`test_ac{N}_...`）に対応したテスト方針が含まれる
- [ ] AC12: 実装の優先順位が依存関係に基づいて整理される
- [ ] AC13: 技術的リスクと対策が明記される
- [ ] AC14: Issue記載内容と実際のコードに差異がある場合、計画書の「前提の確認・補足」セクションで指摘される
- [ ] AC15: 既存ACのサブ機能を計画する場合、AC番号が親仕様書と競合せず `AC{親番号}.{連番}` 形式を使用する
- [ ] AC16: データモデルの削除・変更がある場合、リレーションシップへの影響（カスケード削除等）が計画に含まれる
- [ ] AC17: 操作の権限モデルが計画書に明記される（制限不要の場合も理由を含む）
- [ ] AC18: コマンド型入力がある場合、各トークンの判別ルールが入出力仕様に明記される
- [ ] AC19: 既存コードの振る舞いパターン（スレッド応答、メッセージフォーマット等）が新機能でも踏襲されるよう計画に反映される

## 関連ファイル

| ファイル | 役割 |
|---------|------|
| `.claude/agents/planner.md` | サブエージェント定義（計画プロセスとプロンプト） |
| `docs/specs/overview.md` | 仕様書テンプレート定義（出力フォーマットの参照元） |
| `docs/specs/*.md` | 既存仕様書（類似機能の参照、パターンの把握） |
| `CLAUDE.md` | コーディング規約、プロジェクト構造、LLM使い分けルール |

## テスト方針

Claude Codeサブエージェントは実行時テストが中心となるため、以下を手動で確認:

### 基本動作テスト

- [ ] 新機能のIssueを入力として計画書を生成し、必須セクションが揃っているか
- [ ] 計画書の受け入れ条件が具体的で検証可能か
- [ ] 関連ファイルのリストに役割が記載されているか
- [ ] LLMプロバイダーの選定理由がプロジェクトのルールに沿っているか

### 既存コード調査の検証

- [ ] 類似機能がある場合、既存の仕様書を参照して一貫性のある計画を立てられるか
- [ ] `src/` の既存実装パターンを踏まえた関連ファイルのリストが生成されるか
- [ ] テスト名規約（`test_ac{N}_...`）に対応したテスト方針が含まれるか

### 前提検証・整合性チェック

- [ ] Issue記載の前提（「実装済み」等）と実際のコードが一致するか確認し、差異があれば指摘しているか
- [ ] AC番号が親仕様書の既存AC番号と競合していないか
- [ ] データ削除・変更時のリレーションシップ影響（カスケード削除、孤立レコード等）が考慮されているか
- [ ] 権限モデル（誰が操作できるか）が計画に含まれているか
- [ ] コマンド型入力のトークン判別ルールが明確に定義されているか
- [ ] 既存の振る舞いパターン（スレッド応答等）が新機能でも踏襲されているか

### 品質チェック

- [ ] 計画書が実装者にとって理解しやすく、実装の見通しが立つか
- [ ] 過度に詳細化せず、実装者が自律的に判断できる余地を残しているか
- [ ] 技術的リスクと対策が現実的で実用的か

### レビュー連携

- [ ] 生成した計画書を `doc-reviewerサブエージェント` でレビューし、品質基準を満たしているか確認できる

## 拡張性

将来的に以下の機能を追加可能:

- **自動ファイル生成**: 計画書を `docs/specs/f{N}-{feature}.md` として自動保存
- **Issue連携**: GitHub Issue に計画書を自動でコメント
- **インタラクティブモード**: 計画プロセスの各ステップで開発者に確認・承認を求める
- **複数案の生成**: 異なるアプローチの計画を複数生成し、比較検討を支援
- **見積もり機能**: 実装工数の概算を提示（ただし時間見積もりは不確実性が高いため慎重に）
- **ドラフトコード生成**: 計画書をもとにスケルトンコード（クラス・関数の雛形）を生成

## プランナーの責務の範囲

**計画するもの:**
- 機能仕様の詳細化
- 技術設計の方針
- 受け入れ条件の定義
- テスト戦略
- 実装の優先順位
- リスク評価

**計画しないもの:**
- 具体的なコード実装（関数名、クラス名、詳細なコードスニペット）
- 実装スケジュール（時間見積もり）
- 人員アサイン

計画は実装者が自律的に判断できる範囲を残し、過度に詳細化しない。

## 他サブエージェントとの連携

- **doc-reviewer**: planner で生成した計画書を doc-reviewer でレビューし、品質を向上
- **test-runner**: 計画書の受け入れ条件に基づいてテストを実装した後、test-runner で実行

**推奨ワークフロー:**
1. `plannerサブエージェント` で実装計画を生成
2. `doc-reviewerサブエージェント` で計画書をレビュー
3. レビュー結果をもとに計画書を修正
4. 計画書に基づいて実装
5. `test-runnerサブエージェント` でテストを実行
6. テスト結果をもとに実装を調整
